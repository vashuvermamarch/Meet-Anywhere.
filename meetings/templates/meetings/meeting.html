<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting: {{ room_name }}</title>

    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #4f46e5;
            --bg: #0f172a;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Outfit', sans-serif;
            color: white;
        }

        #meet {
            height: 100vh;
            width: 100vw;
            background-color: var(--bg);
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 14px;
            transition: background 0.2s;
        }

        .back-btn:hover {
            background: rgba(30, 41, 59, 1);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #meet-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <a href="{% url 'index' %}" class="back-btn">‚Üê Leave Meeting</a>
    <button onclick="copyRoomName()" class="back-btn" style="left: 160px; background: var(--primary); border: none; cursor: pointer;">üìã Copy Room Name</button>

    {% if is_host %}
    <div id="request-sidebar" style="position: fixed; right: 0; top: 0; width: 300px; height: 100vh; background: #1e293b; z-index: 1000; border-left: 1px solid rgba(255,255,255,0.1); padding: 20px; display: none;">
        <h3 style="margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;">Joining Requests</h3>
        <div id="request-list" style="margin-top: 20px;">
            <p style="color: #94a3b8; text-align: center;">No pending requests</p>
        </div>
    </div>
    <button id="toggle-sidebar" onclick="toggleSidebar()" style="position: fixed; bottom: 80px; right: 20px; z-index: 1001; background: var(--primary); border: none; border-radius: 50%; width: 50px; height: 50px; color: white; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-size: 20px;">üë•</button>
    {% endif %}

    <div id="meet"></div>

    <div id="meet-loading-overlay">
        <div class="loader"></div>
        <p id="loading-status">Starting meeting...</p>
    </div>

    <script>
        /* ================= production configuration ================= */
        const ROOM_NAME = "{{ room_name_slug }}";
        const RAW_ROOM_NAME = "{{ room_name|escapejs }}";
        const JITSI_DOMAIN = "{{ jitsi_domain|default:'meet.jit.si' }}";
        const JWT_TOKEN = "{{ jwt_token|default:'' }}";
        const USERNAME = "{{ username|escapejs }}";
        const IS_HOST = {{ is_host|yesno:"true,false" }};
        const loadingOverlay = document.getElementById("meet-loading-overlay");

        /* ================= api loader ================= */
        function loadJitsiAPI(domain) {
            return new Promise((resolve, reject) => {
                const scriptId = "jitsi-external-api";
                if (window.JitsiMeetExternalAPI) return resolve();
                if (document.getElementById(scriptId)) return resolve();
                
                const script = document.createElement("script");
                script.id = scriptId;
                script.src = `https://${domain}/external_api.js`;
                script.async = true;
                script.onload = () => resolve();
                script.onerror = () => reject(new Error("Failed to load Jitsi API"));
                document.head.appendChild(script);
            });
        }

        /* ================= meeting orchestration ================= */
        async function initMeeting() {
            if (window._jitsiInitiated) return;
            window._jitsiInitiated = true;

            try {
                await loadJitsiAPI(JITSI_DOMAIN);

                // --- Production Jitsi Options ---
                const options = {
                    roomName: ROOM_NAME,
                    width: "100%",
                    height: "100%",
                    parentNode: document.querySelector('#meet'),
                    userInfo: { displayName: USERNAME },
                    configOverwrite: {
                        prejoinPageEnabled: false,
                        enableLobby: !IS_HOST, // CRITICAL: Only participants hit the lobby
                        startWithAudioMuted: true,
                        startWithVideoMuted: true,
                        disableDeepLinking: true,
                        
                        /* ‚úÖ PARTICIPANT FIREWALL & ROLE ENFORCEMENT */
                        remoteVideoMenu: {
                            disableKick: !IS_HOST,
                            disableGrantModerator: !IS_HOST,
                            disableMute: !IS_HOST,
                            disablePrivateChat: false
                        },
                        disableRemoteMute: !IS_HOST,
                        hideLobbyButton: !IS_HOST,
                        doNotStoreRoom: true,
                        
                        // Feature restrictions for non-hosts
                        recordingService: {
                            enabled: IS_HOST,
                            sharingEnabled: IS_HOST
                        },
                        liveStreamingEnabled: IS_HOST,
                        autoCaption: false,
                        
                        // Disable sensitive settings for participants
                        disableSettings: !IS_HOST,
                        disableAdmins: !IS_HOST
                    },
                    interfaceConfigOverwrite: {
                        TOOLBAR_BUTTONS: IS_HOST ? [
                            'microphone', 'camera', 'closedcaptions', 'desktop', 'fullscreen',
                            'fodeviceselection', 'hangup', 'profile', 'chat', 'recording',
                            'livestreaming', 'etherpad', 'sharedvideo', 'settings', 'raisehand',
                            'videoquality', 'filmstrip', 'invite', 'feedback', 'stats', 'shortcuts',
                            'tileview', 'videobackgroundblur', 'download', 'help', 'mute-everyone',
                            'security'
                        ] : [
                            'microphone', 'camera', 'chat', 'raisehand', 'tileview', 'hangup',
                            'fullscreen', 'fodeviceselection'
                        ],
                        SETTINGS_SECTIONS: IS_HOST ? ['devices', 'language', 'moderator', 'profile', 'calendar'] : ['devices', 'language', 'profile']
                    }
                };

                // --- JWT Logic ---
                // Only apply JWT if we aren't using a public/community community server
                const isOpenCommunity = ["meet.jit.si", "meet.ffmuc.net"].includes(JITSI_DOMAIN);
                
                if (!isOpenCommunity && JWT_TOKEN) {
                    options.jwt = JWT_TOKEN;
                    console.log("[Production] Private JWT Applied");
                } else {
                    console.log("[Production] Using Community Moderator Rules (First In = Moderator)");
                }

                const joinDelay = IS_HOST ? 0 : 1500;

                setTimeout(() => {
                    const api = new JitsiMeetExternalAPI(JITSI_DOMAIN, options);

                    let revealed = false;
                    const revealUI = (source) => {
                        if (revealed) return;
                        revealed = true;
                        loadingOverlay.style.display = "none";
                        console.log(`[Jitsi] UI Reveal: ${source}`);
                    };

                    // ‚úÖ CRITICAL: Reveal instantly for host so they aren't stuck behind our loader
                    if (IS_HOST) {
                        setTimeout(() => revealUI("host-instant-reveal"), 500);
                    }

                    api.addEventListener("videoConferenceJoined", () => {
                        revealUI("conferenceJoined");
                        
                        if (IS_HOST) {
                            console.log("[Jitsi] Host joined successfully.");
                            try {
                                api.executeCommand('toggleLobby', false);
                            } catch(e) {}
                        }
                    });

                    // Handle "Waiting for moderator" on public Jitsi
                    api.addEventListener("moderatorStatusChanged", (e) => {
                        if (IS_HOST && !e.isModerator) {
                            console.warn("Public Jitsi detected. If you see 'Asking to join', please use the Jitsi 'Log-in' button to authenticate as a moderator.");
                        }
                    });

                    api.addEventListener("connectionEstablished", () => revealUI("connectionEstablished"));
                    api.addEventListener("participantJoined", () => revealUI("participantJoined"));

                    // Safety Fallback (10s)
                    setTimeout(() => revealUI("safety-fallback"), 10000);

                    if (IS_HOST) {
                        api.addEventListener("videoConferenceLeft", () => {
                            window.location.href = "{% url 'index' %}";
                        });
                    }

                }, joinDelay);

            } catch (err) {
                console.error("[Fatal] Jitsi bootstrap failed:", err);
                document.getElementById("loading-status").innerText = "‚ùå Connection failed. Please try again.";
            }
        }

        document.addEventListener("DOMContentLoaded", initMeeting);

        function copyRoomName() {
            navigator.clipboard.writeText(RAW_ROOM_NAME).then(() => {
                console.log("[Jitsi] Copied Room Name:", RAW_ROOM_NAME);
                alert("Room Name (Join Code) copied to clipboard: " + RAW_ROOM_NAME);
            });
        }

        /* ‚úÖ HOST APPROVAL GATE LOGIC */
        if (IS_HOST) {
            window.toggleSidebar = function() {
                const sb = document.getElementById('request-sidebar');
                sb.style.display = sb.style.display === 'none' ? 'block' : 'none';
            };

            window.respond = async function(requestId, status) {
                console.log(`[Jitsi] Responding to request ${requestId} with ${status}`);
                try {
                    const response = await fetch(`{% url 'respond_request' room_name=room_name %}`, {
                        method: 'POST',
                        body: JSON.stringify({ request_id: requestId, status: status }),
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (response.ok) {
                        pollRequests();
                    } else {
                        console.error("[Jitsi] Response failed", await response.text());
                    }
                } catch(e) {
                    console.error("[Jitsi] Error responding to request:", e);
                }
            };

            async function pollRequests() {
                try {
                    const response = await fetch(`{% url 'manage_requests' room_name=room_name %}`);
                    const data = await response.json();
                    const list = document.getElementById('request-list');
                    
                    if (data.requests.length === 0) {
                        list.innerHTML = '<p style="color: #94a3b8; text-align: center;">No pending requests</p>';
                    } else {
                        list.innerHTML = '';
                        data.requests.forEach(req => {
                            const div = document.createElement('div');
                            div.className = 'request-item';
                            div.style = 'background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.1);';
                            div.innerHTML = `
                                <div style="font-weight: 600; margin-bottom: 5px;">${req.username}</div>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="window.respond('${req.id}', 'APPROVED')" style="flex: 1; background: #22c55e; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600;">Accept</button>
                                    <button onclick="window.respond('${req.id}', 'DENIED')" style="flex: 1; background: #ef4444; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600;">Deny</button>
                                </div>
                            `;
                            list.appendChild(div);
                        });
                        // Auto-show sidebar if there are new requests
                        const sb = document.getElementById('request-sidebar');
                        if (sb.style.display === 'none') sb.style.display = 'block';
                    }
                } catch(e) {
                    console.error("[Jitsi] Polling error:", e);
                }
                setTimeout(pollRequests, 5000);
            }

            pollRequests();
        }
    </script>
</body>

</html>